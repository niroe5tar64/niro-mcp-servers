# デザインドキュメント テンプレート

---
**目的**: 実装者が異なっても実装の整合性を保ち、解釈のぶれを防ぐために十分な詳細を提供する。

**方針**:
- 実装判断に直接影響する必須セクションのみを含める
- 実装ミス防止に不可欠でない限り、任意セクションは省く
- 機能の複雑さに応じて詳細度を調整する
- 長文よりも図表を優先する

**警告**: 1000行に近づく場合、機能が過度に複雑であり、設計の簡素化が必要になる可能性がある。
---

> セクション順は明確性が高まるなら変更してよい（例: 要件トレーサビリティを前に出す、データモデルをアーキテクチャの近くに移動する）。各セクション内は **概要 → 範囲 → 決定事項 → 影響/リスク** の流れを維持し、レビュー時の走査性を確保する。

## 概要
2-3段落以内
**目的**: 本機能は [具体的な価値] を [対象ユーザー] に提供する。
**利用者**: [対象ユーザー層] が [具体的なワークフロー] に利用する。
**影響**（該当する場合）: 現在の [システム状態] を [具体的な変更内容] により変更する。


### 目標
- 主要目的 1
- 主要目的 2
- 成功基準

### 非目標
- 明示的に除外する機能
- 現在の範囲外の将来検討事項
- 保留する統合ポイント

## アーキテクチャ

> 詳細な調査メモは `research.md` に背景としてのみ参照し、design.md はレビュー用に自己完結させること。決定事項と契約はここに記録する。
> 重要な決定はテキストにまとめ、構造の詳細は図に持たせる。本文で同じ情報を繰り返さない。

### 既存アーキテクチャの分析（該当する場合）
既存システムを変更する場合:
- 現在のアーキテクチャパターンと制約
- 尊重すべき既存のドメイン境界
- 維持すべき統合ポイント
- 解消または回避する技術的負債

### アーキテクチャパターン & 境界マップ
**推奨**: 選択したアーキテクチャパターンとシステム境界を示す Mermaid 図を含める（複雑な機能は必須、単純な追加は任意）

**アーキテクチャ統合**:
- 選択パターン: [名称と簡潔な理由]
- ドメイン/機能境界: [責務分離の方法と衝突回避]
- 既存パターンの保持: [主要パターンの一覧]
- 新規コンポーネントの根拠: [それぞれが必要な理由]
- Steering 準拠: [維持する原則]

### 技術スタック

| 層 | 選択 / バージョン | 機能内の役割 | 備考 |
|-------|------------------|-----------------|-------|
| フロントエンド / CLI | | | |
| バックエンド / サービス | | | |
| データ / ストレージ | | | |
| メッセージング / イベント | | | |
| インフラ / ランタイム | | | |

> ここでは根拠を簡潔に。より深い議論（トレードオフ、ベンチマーク）が必要な場合は、短い要約と Supporting References セクション、および生の調査メモとして `research.md` への参照を追加する。

## システムフロー

非自明なフローを説明するために必要な図のみを掲載する。純粋な Mermaid 構文を使用。一般的なパターン:
- シーケンス（多者間の相互作用）
- プロセス / 状態（分岐ロジックやライフサイクル）
- データ / イベントフロー（パイプライン、非同期メッセージング）

単純な CRUD 変更はこのセクションを完全に省略する。
> フロー上の判断（例: ゲート条件、リトライ）は図の後に簡潔に述べ、各ステップの反復記述は避ける。

## 要件トレーサビリティ

複雑またはコンプライアンスに敏感な機能で、要件が複数ドメインにまたがる場合に使用する。単純な 1:1 の対応は Components の概要表で代替してよい。

各要件ID（例: `2.1`）を、それを実現する設計要素に紐づける。

| 要件 | 概要 | コンポーネント | インターフェース | フロー |
|-------------|---------|------------|------------|-------|
| 1.1 | | | | |
| 1.2 | | | | |

> 単一コンポーネントが単一要件を満たし、横断的な関心がない場合のみこのセクションを省略する。

## コンポーネントとインターフェース

各コンポーネントの詳細に入る前のクイックリファレンスを提供する。

- 要約は表または簡潔なリストでよい。例:
  | コンポーネント | ドメイン/層 | 目的 | 要件カバレッジ | 主要依存（P0/P1） | 契約 |
  |-----------|--------------|--------|--------------|--------------------------|-----------|
  | ExampleComponent | UI | XYZ を表示 | 1, 2 | GameProvider (P0), MapPanel (P1) | Service, State |
- 新しい境界（例: ロジックフック、外部統合、永続化）を導入するコンポーネントのみ、詳細ブロックが必要。単純な表示コンポーネントは概要行と短い Implementation Note で足りる。

詳細ブロックはドメインまたはアーキテクチャ層でグループ化する。詳細コンポーネントでは要件IDを `2.1, 2.3` のように列挙（"Requirement" は省略）。複数の UI コンポーネントが同一の契約を共有する場合は、ベースとなる interface/props 定義を参照し、コードブロックの重複を避ける。

### [ドメイン / 層]

#### [コンポーネント名]

| 項目 | 詳細 |
|-------|--------|
| 目的 | 責務の1行説明 |
| 要件 | 2.1, 2.3 |
| オーナー / レビュアー | （任意） |

**責務と制約**
- 主たる責務
- ドメイン境界とトランザクション範囲
- データ所有権 / 不変条件

**依存関係**
- インバウンド: コンポーネント/サービス名 — 目的（重要度）
- アウトバウンド: コンポーネント/サービス名 — 目的（重要度）
- 外部: サービス/ライブラリ — 目的（重要度）

外部依存の詳細調査（API シグネチャ、レート制限、移行メモなど）は `research.md` に記載し、ここでは要約のみ。

**契約**: Service [ ] / API [ ] / Event [ ] / Batch [ ] / State [ ]  ← 該当するものだけチェック。

##### サービスインターフェース
```typescript
interface [ComponentName]Service {
  methodName(input: InputType): Result<OutputType, ErrorType>;
}
```
- 事前条件:
- 事後条件:
- 不変条件:

##### API 契約
| Method | Endpoint | Request | Response | Errors |
|--------|----------|---------|----------|--------|
| POST | /api/resource | CreateRequest | Resource | 400, 409, 500 |

##### イベント契約
- 公開イベント:
- 購読イベント:
- 順序 / 配信保証:

##### バッチ / ジョブ契約
- トリガー:
- 入力 / 検証:
- 出力 / 宛先:
- 冪等性と復旧:

##### 状態管理
- 状態モデル:
- 永続化と整合性:
- 競合戦略:

**実装メモ**
- 統合:
- 検証:
- リスク:

## データモデル

本機能で変化するデータ領域に焦点を当てる。

### ドメインモデル
- 集約とトランザクション境界
- エンティティ、値オブジェクト、ドメインイベント
- ビジネスルールと不変条件
- 複雑な関係には任意で Mermaid 図

### 論理データモデル

**構造定義**:
- エンティティ関係と多重度
- 属性と型
- 自然キーと識別子
- 参照整合性ルール

**整合性と完全性**:
- トランザクション境界
- カスケードルール
- 時間的側面（バージョニング、監査）

### 物理データモデル
**含める条件**: 実装に特定のストレージ設計判断が必要な場合

**リレーショナル DB の場合**:
- データ型を含むテーブル定義
- 主キー/外部キーと制約
- インデックスと性能最適化
- スケールのためのパーティショニング戦略

**ドキュメントストアの場合**:
- コレクション構造
- 埋め込み vs 参照の判断
- シャーディングキー設計
- インデックス定義

**イベントストアの場合**:
- イベントスキーマ定義
- ストリーム集約戦略
- スナップショットポリシー
- プロジェクション定義

**Key-Value / ワイドカラムストアの場合**:
- キー設計パターン
- カラムファミリまたは値構造
- TTL とコンパクション戦略

### データ契約 & 統合

**API データ転送**
- リクエスト/レスポンススキーマ
- バリデーションルール
- シリアライズ形式（JSON、Protobuf など）

**イベントスキーマ**
- 公開イベント構造
- スキーマバージョニング戦略
- 後方/前方互換性ルール

**サービス間データ管理**
- 分散トランザクションパターン（Saga, 2PC）
- データ同期戦略
- 最終的整合性の扱い

本機能に関係しない小節は省略する。

## エラーハンドリング

### エラー戦略
各エラー種別の具体的な処理パターンと復旧メカニズム。

### エラーカテゴリと対応
**ユーザーエラー**（4xx）: 不正入力 → フィールドレベル検証; 未認可 → 認可ガイダンス; 未検出 → ナビゲーション支援
**システムエラー**（5xx）: インフラ障害 → グレースフルデグラデーション; タイムアウト → サーキットブレーカー; 資源枯渇 → レート制限
**ビジネスロジックエラー**（422）: ルール違反 → 条件説明; 状態競合 → 遷移ガイダンス

**プロセスフロー可視化**（複雑な業務ロジックがある場合）:
複雑なエラーシナリオと業務フローがある場合のみ、Mermaid フローチャートを含める。

### 監視
エラートラッキング、ロギング、ヘルスモニタリングの実装。

## テスト戦略

### 既定セクション（ドメインに合わせて名称/セクションを調整）
- ユニットテスト: 中核関数/モジュールから 3–5 項目（例: 認証メソッド、サブスクリプションロジック）
- 統合テスト: コンポーネント横断フローを 3–5 項目（例: webhook 処理、通知）
- E2E/UI テスト（該当時）: 重要ユーザーパスを 3–5 項目（例: フォーム、ダッシュボード）
- パフォーマンス/負荷（該当時）: 3–4 項目（例: 並行性、大量処理）

## 任意セクション（必要時のみ）

### セキュリティ考慮
_認証、機微データ、外部統合、権限を扱う機能で使用する。この機能固有の決定のみを記録し、ベースラインの制御はステアリング文書に委ねる。_
- 脅威モデリング、セキュリティ制御、コンプライアンス要件
- 認証/認可パターン
- データ保護とプライバシー考慮

### パフォーマンス & スケーラビリティ
_性能目標、高負荷、スケーリング懸念がある場合に使用。機能固有の目標やトレードオフのみを記録し、一般的な方針はステアリング文書に委ねる。_
- 目標指標と測定戦略
- スケーリング手法（水平/垂直）
- キャッシュ戦略と最適化手法

### 移行戦略
スキーマ/データ移行が必要な場合、移行フェーズを示す Mermaid フローチャートを含める。
- フェーズ分解、ロールバックトリガー、検証チェックポイント

## 参考資料（任意）
- 本文に含めると可読性を損なう場合（例: 長い TypeScript 定義、ベンダー比較表、網羅的スキーマ表）のみ作成する。決定の文脈は本文に残し、設計の自己完結性を保つ。
- 本文からは Supporting References へのリンクで参照し、長いスニペットはインライン化しない。
- 背景調査メモや比較は `research.md` に置き続けるが、その結論は本文に要約する。
