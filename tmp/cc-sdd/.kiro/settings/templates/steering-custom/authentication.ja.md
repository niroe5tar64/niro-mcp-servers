# 認証・認可標準

[目的: 認証モデル、トークン/セッションのライフサイクル、権限チェック、セキュリティを統一する]

## フィロソフィー
- 明確な分離: 認証（誰） vs 認可（何ができるか）
- セキュアデフォルト: 最小権限、フェイルクローズ、短命トークン
- UX 配慮: リスクが高いところは摩擦を高め、それ以外は滑らかに

## 認証

### 方法（選択 + 根拠）
- 選択肢: JWT, セッション, OAuth2, ハイブリッド
- 選択: [our method] because [reason]

### フロー（ハイレベル）
```
1) ユーザーが本人性を証明（資格情報またはプロバイダ）
2) サーバが検証し、トークン/セッションを発行
3) クライアントがリクエストごとにトークンを送信
4) サーバがトークンを検証して処理を継続
```

### トークン/セッションライフサイクル
- 保存先: httpOnly cookie か Authorization ヘッダ
- 有効期限: 短命アクセス、長めのリフレッシュ（使用時）
- リフレッシュ: トークンをローテーションし、失効に配慮
- 失効: ログアウト/漏えい時はブラックリストまたはローテーション

### セキュリティパターン
- TLS を強制; 可能ならトークンを JS から隠す
- トークンに audience/issuer を紐づけ、クレームは最小限
- 重要操作ではデバイス紐づけや IP/リスクチェックを検討

## 認可

### 権限モデル
- いずれかを選ぶ: RBAC / ABAC / 所有者ベース / ハイブリッド
- ロール/属性は中央管理し、コード中のハードコードを避ける

### チェック（適用場所）
- ルート/ミドルウェア: 粗いゲート
- ドメイン/サービス: 細かな判断
- UI: 条件付き表示（セキュリティの根拠にはしない）

例パターン:
```typescript
requirePermission('resource:action'); // route
if (!user.can('resource:action')) throw ForbiddenError(); // domain
```

### 所有権
- パターン: 所有者 または 特権ロールが操作可能
- 変更前にエンティティ境界で検証

## パスワード & MFA
- パスワード: 強いポリシー、ハッシュ化（bcrypt/argon2）、平文禁止
- リセット: 期限付きトークン、単回利用、ユーザー通知
- MFA: 高リスク操作にステップアップ（ポリシー駆動）

## API-to-API 認証
- API キーまたは OAuth クライアント認証情報を使用
- キーのスコープを最小化し、ローテーションと監査を行う
- ユーザー/キー単位でレート制限

---
_パターンと判断に集中する。ライブラリ固有のコードは記載しない。_
