# エラーハンドリング標準

[目的: エラーの分類、形状、伝播、ログ、監視を統一する]

## フィロソフィー
- 可能な限りフェイルファスト; システム境界ではグレースフルデグラデーション
- スタック全体で一貫したエラー形状（人間/機械可読）
- 既知のエラーは発生源の近くで扱い、未知はグローバルハンドラへ

## 分類（発生源で扱いを決める）
- クライアント: 入力/検証/ユーザー操作の問題 → 4xx
- サーバ: システム障害/予期せぬ例外 → 5xx
- ビジネス: ルール/状態違反 → 4xx（例: 409）
- 外部: サードパーティ/ネットワーク障害 → 文脈に応じて 5xx または 4xx にマッピング

## エラー形状（単一の正準フォーマット）
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable message",
    "requestId": "trace-id",
    "timestamp": "ISO-8601"
  }
}
```
原則: 安定したコード列挙、シークレット非公開、トレース情報を含める。

## 伝播（変換の場所）
- API レイヤ: ドメインエラー → HTTP ステータス + 正準ボディ
- サービスレイヤ: 型付きビジネスエラーを投げ、文字列ベースのエラーは避ける
- データ/外部レイヤ: プロバイダエラーを安全で実行可能なコードに包む
- 未知のエラー: グローバルハンドラに伝播 → 500 + 汎用メッセージ

例パターン:
```typescript
try { return await useCase(); }
catch (e) {
  if (e instanceof BusinessError) return respondMapped(e);
  logError(e); return respondInternal();
}
```

## ロギング（ノイズより文脈）
記録: operation, userId（可能なら）, code, message, stack, requestId, 最小限の文脈。
記録しない: パスワード、トークン、シークレット、完全な PII、機密データを含む全文ボディ。
レベル: ERROR（障害）, WARN（復旧可能/エッジ）, INFO（主要イベント）, DEBUG（診断）。

## リトライ（安全な場合のみ）
リトライする条件: ネットワーク/タイムアウト/一時的 5xx かつ操作が冪等。
リトライしない: 4xx、ビジネスエラー、非冪等フロー。
戦略: 指数バックオフ + ジッタ、試行回数に上限; 冪等キー必須。

## 監視 & ヘルス
追跡: コード/カテゴリ別エラーレート、レイテンシ、飽和度; スパイク/SLI 逸脱でアラート。
公開: `/health`（live）, `/health/ready`（ready）。エラーはトレースと紐づける。

---
_パターンと判断に集中する。実装詳細や網羅的な一覧は避ける。_
